{"version":3,"sources":["webpack://covid-game/./src/sass/default.scss","webpack://covid-game/./src/game-engine.js","webpack://covid-game/./src/main.js","webpack://covid-game/./src/map-plot.js","webpack://covid-game/webpack/bootstrap","webpack://covid-game/webpack/runtime/compat get default export","webpack://covid-game/webpack/runtime/define property getters","webpack://covid-game/webpack/runtime/hasOwnProperty shorthand","webpack://covid-game/webpack/runtime/make namespace object","webpack://covid-game/webpack/startup"],"names":[],"mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;ACAA;;AAEA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,iCAAiC,sCAAsC;AACvE;AACA;;;AAGA;;AAEO;AACP;AACA;;AAEA;AACA,mBAAmB;AACnB,qBAAqB;AACrB,uBAAuB;AACvB,uBAAuB;AACvB,kBAAkB;AAClB,yBAAyB;AACzB,wBAAwB;AACxB,6BAA6B;AAC7B,yBAAyB;AACzB,2BAA2B;;AAE3B;AACA,kCAAkC;AAClC,6BAA6B;AAC7B,6BAA6B;AAC7B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,6CAA6C;AAC7C,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,uCAAuC;AACvC,oCAAoC;AACpC;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA,kBAAkB,wDAAwD,WAAW;AACrF,kBAAkB,wDAAwD,kBAAkB;;AAE5F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe,OAAO;AACxD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AA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ACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,wDAAwD,iCAAiC,oBAAoB,kBAAkB;AAC/H;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA,0DAA0D,iCAAiC,oBAAoB,aAAa;AAC5H;AACA;AACA;AACA;AACA,wDAAwD,mDAAmD,oBAAoB,iBAAiB;AAChJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;AAGO;AACP;AACA;AACA;AACA,wBAAwB,4DAAc;AACtC,KAAK;AACL,G;;;;;;;;;;;;;;;;UCtEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"bundle.77c81bb2fe39860cde3b.js","sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","// Core data structures\n\n// We have the state of the Country and of the individual regions first.\n// These contain the timelines for various quantities, as well as some\n// basic information attached to either.\n\nexport class Country {\n    constructor() {\n\n        // Here we can also save summary information that we want to show\n        // like highscore data, number of people who died, number of\n        // person-days in lockdown, etc...\n\n        this.S = []\n        this.E = []\n        this.I = []\n        this.Em = []\n        this.Im = []\n        this.R = []\n\n        this.ratio_vac = 0\n        this.deaths = []\n    }\n}\n\nclass Region {\n\n    constructor(N_S, N_E, N_I, N_Em, N_Im, N_R, N_total, tag, name) {\n\n        // These should be arrays        \n        this.S = N_S\n        this.E = N_E\n        this.I = N_I\n        this.Em = N_Em\n        this.Im = N_Im\n        this.R = N_R\n\n        this.total = N_total\n\n        this.travel_I = 0 // total traveling infected neighbours\n        this.travel_Im = 0 // total traveling infected neighbours with mutant\n\n        this.tag = tag\n        this.name = name\n        this.neighbours = Array() // Needs to be populated later\n    }\n}\n\n// An important way to initialize a region is given an incidence and a total number of people\n\nexport function region_with_incidence(total, incidence, tag, name) {\n    let I = [incidence / 100000 * total];\n    let E = [I[0] * 0.7];\n    let R = [0];\n    let S = [total - I[0]];\n    return new Region(S, E, I, [0], [0], R, total, tag, name);\n}\n\n\nfunction region_100k_u0_9_infected() {\n    let total = 100000\n    let trace_capacity = total * 0.01;\n    let I = [Math.round(10 * Math.random())]\n    let Im = [0]\n    let E = [0]\n    let Em = [0]\n    let R = [0]\n    let S = [total - I[0]]\n    return new Region(S, E, I, Em, Im, R, total, trace_capacity, \"000\", \"LK\")\n}\n\nfunction connect_regions_randomly(Regions) {\n    let n_reg = Regions.length\n    for (let reg of Regions) {\n        for (let n = 0; n < n_reg; n++)\n            reg.neighbours.push({ dist: Math.random() * 500, index: n })\n    }\n}\n\n\n// We then have the parameters for the disease and death model, as well as some properties derived from the parameters.\n\nexport class DynParameters {\n    constructor() {\n        // The parameters of the disease and the vaccination campaign\n\n        // Disease dynamics\n        this.mu = { value: 3, def: 3, desc: \"Base R0: Number of people an infected infects on average.\" }\n        this.mu_m = { value: 4, def: 4, desc: \"Base R0 for Mutant: Number of people someone infected by the mutant infects on average.\" }\n        this.I_to_R = { value: 0.2, def: 0.2, desc: \"Daily rate of end of infectiousness (leading to recovery or death).\" }\n        this.E_to_I = { value: 0.4, def: 0.4, desc: \"Daily rate of infection breaking out among those carrying the virus (they become infectious for others).\" }\n        this.k = { value: 0.1, def: 0.1, desc: \"Overdispersion: Not everyone infects exactly R0 people, this parameter controls how much the number of infected varies from person to person.\" }\n        this.vac_rate = { value: 0.001, def: 0.001, desc: \"Fraction of population vaccinated per day.\" }\n        this.vac_eff = { value: 0.8, def: 0.8, desc: \"Fraction of infections prevented by vaccination.\" }\n        this.tti_capacity = { value: 0.0001, def: 0.0001, desc: \"Trace capacity as fraction of total local population.\" }\n        this.bck_rate = { value: 0.5, def: 0.5, desc: \"Average number of infected coming into each region per day from outside the country.\" }\n        this.bck_rate_m = { value: 0.5, def: 0.5, desc: \"Average number of mutant infected coming into each region per day from outside the country.\" }\n\n        // Death model\n        this.hospital_capacity = { value: 0.001, def: 0.001, desc: \"ICU capacity as a fraction of population.\" }\n        this.death_rate_1 = { value: 0.01, def: 0.01, desc: \"Fraction of deaths for people within hospital capactity.\" }\n        this.death_rate_2 = { value: 0.05, def: 0.05, desc: \"Fraction of deaths for people beyond hospital capactity.\" }\n        this.vulnerable = { value: 0.2, def: 0.2, desc: \"Fraction of vulnerable in the population.\" }\n        this.non_vul_dr = { value: 0.1, def: 0.1, desc: \"Rate of serious complications/deaths among non-vulnerable population relative to overall population (this modifier gradually kicks in as the vulnerable get vaccinated).\" }\n    }\n}\n\nfunction deaths(dyn_pars, I, v_rate, delta_R, N_total) {\n    // death model\n    // We assume vaccination prevents hospitalization\n    // Then take the ratio of hospital capacity to the number of unvaccinated infected.\n    let hos = N_total * dyn_pars.hospital_capacity.value / ((1 - v_rate) * I)\n    let base_dr\n    let dr\n    if (hos > 1) {\n        base_dr = dyn_pars.death_rate_1.value\n    } else {\n        base_dr = hos * dyn_pars.death_rate_1.value + (1 - hos) * dyn_pars.death_rate_2.value\n    }\n\n    // We assume that once the vulnerable are infected mortality will be much lower\n    if (v_rate > dyn_pars.vulnerable.value) { dr = base_dr * dyn_pars.non_vul_dr.value }\n    else { dr = ((1 - v_rate) + v_rate * dyn_pars.non_vul_dr.value) * base_dr }\n\n    return prob_round(dr * delta_R)\n}\n\nclass DerivedProps {\n    constructor(dyn_pars) {\n        this.time_to_infectious = { value: 1 + (1 - dyn_pars.E_to_I.value) / dyn_pars.E_to_I.value, desc: \"Average time until an infected person becomes infectious.\" }\n        this.time_of_infectiousness = { value: 1 + (1 - dyn_pars.I_to_R.value) / dyn_pars.I_to_R.value, desc: \"Average time a person is infectious.\" }\n        // this.superspreader_20 = {value: ..., desc: \"20% of people infect this fraction of the total amount of infected.\"}\n    }\n}\n\n\n// The core dynamic of the SEIR model is given next in terms of binomial and negative binomial distributions\n// Our negative binomial diefinition follows that of Wikipedia.\n\nfunction normal(mean, variance) {\n    // Box-Muller Transform\n    let u1 = Math.random()\n    let u2 = Math.random()\n    let z = Math.sqrt(-2. * Math.log(u1)) * Math.cos(2 * Math.PI * u2)\n    let n = mean + z * Math.sqrt(variance)\n    if (n < 0.) {n = 0.}\n    return Math.round(n)\n}\n\nfunction binom(N, p) {\n\n    // Performance optimisation\n    let mean = N*p\n    let anti_mean = N*(1-p)\n    \n    if (mean > 10 && anti_mean > 10){\n        return normal(mean, mean*(1-p))\n    }\n\n    // actual simulation\n    let suc = 0\n    for (let n = 0; n < N; n++) {\n        if (Math.random() < p) { suc++ }\n    }\n    return suc\n}\n\nfunction neg_binom(r, p) {\n    if (p == 0.) { console.log(\"Negative binomial was called with p = 0\"); return 0 } // Convenient failure mode\n    if (p == 1.) { console.log(\"Negative binomial was called with p = 1\"); return Infinity } // Convenient failure mode\n\n    // Performance optimisation, for justification of cutoff 20 see the Julia playground\n    let mean = r*p/(1-p)\n    if (mean > 20){\n        let variance = mean/(1-p)\n        return normal(mean, variance)\n    }\n\n    // actual simulation\n    let suc = 0;\n    let fai = 0;\n    while (fai < r) {\n        if (Math.random() < p) { suc++ } else { fai++ }\n    }\n    return suc\n}\n\nfunction prob_round(x) {\n    // This function rounds to the integer i below x with probability 1 - (x - i),\n    // and to the integer above otherwise. In terms of linear expectation values\n    // this is a smooth rounding function. :)\n    let i = Math.floor(x)\n    if (Math.random() < (x - i)) { return i + 1 } else { return i }\n}\n\nfunction get_deltas(E, I, I_travel, E_to_I, I_to_R, mu, k, v, background) {\n\n    let delta_E = 0 // newly exposed\n    let delta_I = 0 // newly infected\n    let delta_R = 0 // newly removed\n\n    delta_I = binom(E, E_to_I)\n    delta_R = binom(I, I_to_R)\n\n    // we need to get the paremters r and p from the mu and k which we specify / which the measures\n    // affect directly.\n    let d_infect = (1 + (1 - I_to_R) / I_to_R)\n    let mu_d = mu / d_infect\n    let r = 1 / k\n    let p = mu_d / (r + mu_d)\n\n    let I_eff = (1 - v) * (I + I_travel) + background\n    let size = prob_round(r * I_eff)\n    delta_E = neg_binom(size, p)\n\n    return [delta_E, delta_I, delta_R]\n}\n\n// We can show how the disease model looks for an individual if everyone else is susceptible:\n\nfunction one_person_timeline(E_to_I, I_to_R, mu, k) {\n    let d_e = 0\n    let E = 1\n    let I = 0\n    let I_travel = 0\n    let v = 0\n    let background = 0\n    let delta_I = 0\n    while (delta_I == 0) {\n        let deltas = get_deltas(E, I, I_travel, E_to_I, I_to_R, mu, k, v, background)\n        d_e++\n        delta_I = deltas[1]\n    }\n\n    E = 0\n    I = 1\n\n    let infect = []\n    let delta_R = 0\n    while (delta_R == 0) {\n        let deltas = get_deltas(E, I, I_travel, E_to_I, I_to_R, mu, k, v, background)\n        delta_R = deltas[2]\n        infect.push(deltas[0])\n    }\n\n    return [d_e, infect]\n}\n\nfunction one_person_timeline_average(dyn_pars, N) {\n    let timeline = [0]\n    let totals = [0]\n    let total = 0\n    for (let n = 0; n < N; n++) {\n        let opl = one_person_timeline(dyn_pars.E_to_I.value, dyn_pars.I_to_R.value, dyn_pars.mu.value, dyn_pars.k.value)\n        while ((opl[1].length + opl[0]) > timeline.length) { timeline.push(0) }\n        total = 0\n\n        for (let m = 0; m < opl[1].length; m++) {\n            timeline[m + opl[0]] += opl[1][m]\n            total += opl[1][m]\n        }\n\n        while (total > totals.length - 1) { totals.push(0) }\n\n        totals[total] += 1\n    }\n\n    for (let m = 0; m < timeline.length; m++) {\n        timeline[m] /= N\n    }\n\n    // for (let m = 0; m < totals.length; m++) {\n    //     totals[m] /= N\n    // }\n\n    return [totals, timeline]\n}\n\n// We now come to the model of the measures\n\nexport class Measures {\n    constructor() {\n\n        this.gatherings_1000 = { value: 1 - 0.2, active: false, desc: \"No gatherings with more than 1000 people\" }\n        this.gatherings_100 = { value: 1 - 0.25, active: false, desc: \"No gatherings with more than 100 people\" }\n        this.gatherings_10 = { value: 1 - 0.35, active: false, desc: \"No gatherings with more than 10 people\" }\n        this.schools_unis_closed = { value: 1 - 0.4, active: false, desc: \"Schools and Universities are closed\" }\n        this.some_business_closed = { value: 1 - 0.2, active: false, desc: \"Selected (high-traffic) buisnesses are closed\" }\n        this.all_business_closed = { value: 1 - 0.3, active: false, desc: \"All non-essential buisnesses are closed\" }\n        this.test_trace_isolate = { value: 1 - 0.33, active: false, desc: \"Trace & isolate infected persons\" }\n        this.stay_at_home = { value: 1 - 0.1, active: false, desc: \"Strict 'stay at home' orders\" }\n    }\n\n    toggle(key) {\n        this[key].active = !this[key].active;\n    }\n}\n\nfunction measure_effect(cm) {\n    // This is how I interpret the slide. Might or might not be true:\n    let mu_mult = 1.\n    Object.keys(cm).filter(m => cm[m].active && m != \"test_trace_isolate\").map(m => { mu_mult *= cm[m].value })\n    return mu_mult\n}\n\nfunction tti_eff(infected, trace_capacity, cm) {\n    // rough model is Just dreamed up of test, trace, isolate efficiency,\n    // if we can trace everyone we reduce R by 1/3rd\n    // if not we reduce it by 1/3rd for the fraction traced and not at all for the rest.\n    if (infected < trace_capacity) { return cm.test_trace_isolate.value }\n    else { return (cm.test_trace_isolate.value * trace_capacity / infected + (infected - trace_capacity) / infected) }\n}\n\n\n// Now putting things together for a local SEIR step\n\nfunction local_step(reg, country, dyn_pars, cm, mu_mult) {\n\n    let now = reg.S.length - 1\n\n    let s_adjust = reg.S[now] / reg.total\n\n    if (reg.S[now] < 0) { console.log(\"Something went wrong, S went negative\") }\n\n    let local_mu = s_adjust * mu_mult * dyn_pars.mu.value\n    let local_mu_m = s_adjust * mu_mult * dyn_pars.mu_m.value\n\n    if (cm.test_trace_isolate.active) {\n        const te = tti_eff(reg.I[now] + reg.Im[now], dyn_pars.tti_capacity.value * reg.total, cm)\n        local_mu *= te\n        local_mu_m *= te\n    }\n\n    let v_eff = country.ratio_vac * dyn_pars.vac_eff.value\n\n    let deltas = get_deltas(reg.E[now], reg.I[now], reg.travel_I, dyn_pars.E_to_I.value, dyn_pars.I_to_R.value, local_mu, dyn_pars.k.value, v_eff, dyn_pars.bck_rate.value)\n\n    let delta_E = deltas[0] // newly exposed\n    let delta_I = deltas[1] // newly infectious\n    let delta_R = deltas[2] // newly removed\n\n    let deltas_m = get_deltas(reg.Em[now], reg.Im[now], reg.travel_Im, dyn_pars.E_to_I.value, dyn_pars.I_to_R.value, local_mu_m, dyn_pars.k.value, v_eff, dyn_pars.bck_rate_m.value)\n\n    let delta_Em = deltas_m[0] // newly exposed mutant\n    let delta_Im = deltas_m[1] // newly infectious mutant\n    let delta_Rm = deltas_m[2] // newly removed mutant\n\n    // Handle the case when the last susceptible in a region become exposed:\n    let c1 = reg.S[now] - delta_E - delta_Em\n\n    if (c1 > 0) {\n        reg.S.push(reg.S[now] - delta_E - delta_Em)\n    }\n    else {\n        reg.S.push(0)\n        delta_E = reg.S[now]\n        delta_Em = 0\n    }\n\n    // Push to the data arrays\n    reg.E.push(reg.E[now] + delta_E - delta_I)\n    reg.Em.push(reg.Em[now] + delta_Em - delta_Im)\n    reg.I.push(reg.I[now] + delta_I - delta_R)\n    reg.Im.push(reg.Im[now] + delta_Im - delta_Rm)\n    reg.R.push(reg.R[now] + delta_R + delta_Rm)\n\n    return deaths(dyn_pars, reg.I[now] + reg.Im[now], country.ratio_vac, delta_R + delta_Rm, reg.total)\n}\n\n\nexport function step_epidemic(country, regions, cm, dyn_pars, travel) {\n\n    country.ratio_vac += dyn_pars.vac_rate.value // Vaccinate some people\n\n    console.log(country.ratio_vac)\n\n    // travel is the fraction of people from a region that travel to a neighbouring region\n    // in our first approximation these are simply all regions within 100km and travel is a constant fraction.\n    // these people cause infections at the place they travel to as well as at home.\n\n    for (let reg of regions) {\n        let now = reg.S.length - 1;\n\n        reg.travel_I = 0\n        reg.travel_Im = 0\n        for (let nei of reg.neighbours) {\n            if (nei.dist < 100 && reg != regions[nei.index]) {\n                reg.travel_I += Math.round(travel * regions[nei.index].I[now])\n                reg.travel_Im += Math.round(travel * regions[nei.index].Im[now])\n            }\n        }\n    }\n\n    let mu_mult = measure_effect(cm)\n    let d = 0\n\n    for (let reg of regions) {\n        d += local_step(reg, country, dyn_pars, cm, mu_mult)\n    }\n\n    country.S.push(count(S_now, regions))\n    country.E.push(count(E_now, regions))\n    country.I.push(count(I_now, regions))\n    country.Em.push(count(Em_now, regions))\n    country.Im.push(count(Im_now, regions))\n    country.R.push(count(R_now, regions))\n    country.deaths.push(d)\n    // debug output\n    // let re = regions[2]\n\n    // let now = re.S.length - 1\n\n    // let s_adjust = re.S[now] / re.total\n\n    // let local_r  = s_adjust * mu_mult * dyn_pars.mu.value\n    // console.log(tti_eff(re.I[now] + re.Im[now], dyn_pars.tti_capacity.value * reg.total, cm), mu_mult, local_r)\n    // console.log(cm.gatherings_1000.active)\n\n}\n\nfunction get_current(field) { return field[field.length - 1]; }\nfunction count(proj, r) { return r.reduce((a, v) => a + proj(v), 0); }\n\nfunction exposed(reg) { return get_current(reg.E) + get_current(reg.Em); }\nfunction infectious(reg) { return get_current(reg.I) + get_current(reg.Im); }\nfunction infected(reg) { return exposed(reg) + infectious(reg); }\nfunction recovered(reg) { return get_current(reg.R); }\nfunction susceptible(reg) { return get_current(reg.S); }\nfunction total(reg) { return reg.total; }\n\nfunction count_infectious(Regions) { return count(infectious, Regions); }\nfunction count_exposed(Regions) { return count(exposed, Regions); }\nfunction count_recovered(Regions) { return count(recovered, Regions); }\nfunction count_susceptible(Regions) { return count(susceptible, Regions); }\n\nfunction S_now(reg) { return get_current(reg.S); }\nfunction E_now(reg) { return get_current(reg.E); }\nfunction I_now(reg) { return get_current(reg.I); }\nfunction Em_now(reg) { return get_current(reg.Em); }\nfunction Im_now(reg) { return get_current(reg.Im); }\nfunction R_now(reg) { return get_current(reg.R); }\n\n\n\n//\nfunction average(arr) { return arr.reduce((a, v) => a + v, 0) / arr.length; }\n\n// TODO: fix the projections above so that we can use them here\nexport function avg7_incidence(reg) {\n    let c = 0, s = 0;\n    for (let i = reg.I.length - 1; i >= 0; i--) {\n        c++;\n        s += ((reg.I[i] + reg.Im[i] + reg.E[i] + reg.Em[i]) / reg.total) * 100000;\n\n        if (c > 7) { break; }\n    }\n    return (s / c) || 0;\n}\n\n//tti = Test Trace Isolate\n\nfunction tti_over_capacity(Regions, dyn_pars) {\n    let tti = 0\n    for (let reg of Regions) {\n        if (reg.I[reg.I.length - 1] + reg.Im[reg.Im.length - 1] > dyn_pars.tti_capacity.value * reg.total) { tti += 1 }\n    }\n    return tti\n}\n\nfunction tti_global_effectiveness(Regions, dyn_pars, cm) {\n    let tti_prevented = 0\n    let n = Regions.length\n    for (let reg of Regions) {\n        let tti = tti_eff(infected(reg), dyn_pars.tti_capacity.value * reg.total, cm)\n        let tti_max = tti_eff(0, dyn_pars.tti_capacity.value * reg.total, cm)\n        tti_prevented += (1 - tti) / (1 - tti_max)\n    }\n    return tti_prevented / n\n}\n\n// First naive implementation, use projections once they can look into the past?\nfunction get_timelines(Country) {\n    // ToDo: check that length Regions > 0\n    let S = Country.S\n    let E = Country.E\n    let I = Country.I\n    let Im = Country.Im\n    let Em = Country.Em\n    let R = Country.R\n    return { S: S, E: E, I: I, Im: Im, Em: Em, R: R }\n}\n\n// Things that we really want to show in the front end:\n// * Graphs of SEIR EmIm (and V once implemented) -> use get_timelines(Regions)\n// * Overall test trace isolate effectiveness (also timeline?) -> use tti_global_effectiveness(Regions)\n\n// Things we really want to show but that need a tiny bit of modeling:\n// * Total counter of Deaths and Long Covid cases results in R (simple proportional to start with)\n// * Total counter of people that went R while health system is overtaxed.\n\n// Nice to haves:\n// * On the map: Switch to mutation only.\n// * On the map: Switch to tti effectiveness.\n// * On the map: Switch to incidence rising/sinking.\n// * Graph of how many people every person infects.\n// * Change map to travel network.\n\n\nfunction init_random_regions() {\n    let Regions = []\n\n    for (let n = 0; n < 420; n++) {\n        Regions.push(region_100k_u0_9_infected())\n    }\n\n    connect_regions_randomly(Regions, 2000)\n    return Regions\n}\n\nfunction log_reg(Regions, dyn_pars, cm) {\n    console.log([tti_global_effectiveness(Regions, dyn_pars, cm), count_susceptible(Regions), count_exposed(Regions), count_infectious(Regions), count_recovered(Regions)])\n}\nfunction log_country(country) {\n    console.log([S_now(country), E_now(country), I_now(country), R_now(country)])\n}\n\nfunction self_test() {\n\n    let Regions = init_random_regions()\n    let c_meas = new Measures()\n    let country = new Country()\n    let dyn_pars = new DynParameters()\n\n    console.log(one_person_timeline_average(dyn_pars, 1000))\n\n    return\n\n    for (let n = 0; n < 15; n++) {\n        log_reg(Regions, dyn_pars, c_meas)\n\n        step_epidemic(country, Regions, c_meas, dyn_pars, 0.01)\n    }\n\n    console.log(\"Starting test and trace program\")\n    c_meas.test_trace_isolate.active = true\n\n    for (let n = 0; n < 15; n++) {\n        log_reg(Regions, dyn_pars, c_meas)\n\n        step_epidemic(country, Regions, c_meas, dyn_pars, 0.01)\n    }\n    console.log(\"Switching on all counter measures\")\n\n    c_meas.gatherings_1000.active = true\n    c_meas.gatherings_100.active = true\n    c_meas.gatherings_10.active = true\n    c_meas.schools_unis_closed.active = true\n    c_meas.some_business_closed.active = true\n    c_meas.all_business_closed.active = true\n    c_meas.test_trace_isolate.active = true\n    c_meas.stay_at_home.active = true\n\n    for (let n = 0; n < 25; n++) {\n        log_reg(Regions, dyn_pars, c_meas)\n\n        step_epidemic(country, Regions, c_meas, dyn_pars, 0.01)\n    }\n    log_reg(Regions, dyn_pars, c_meas)\n    log_country(country)\n    console.log(get_timelines(country).S.length)\n\n}\n\nself_test();\n","import {\n  State,\n  init_Params_Measures,\n  start_sim,\n} from './simulation-control';\nimport {\n  initLegend,\n} from './map-plot';\nimport \"./sass/default.scss\";\n\n\n\nvar gState = new State();\n\n//---- Controls ---------------------------------------------------------------------------------------------------------------\n\n// const MAX_DAYS = 200;\nvar runner = document.getElementById(\"run\");\nconst RunButtonContents = {\n  PAUSED: \"<i class='icon ic-run'></i> Run the simulation\",\n  RUNNING: \"<i class='icon ic-pause'></i> Pause the simulation\",\n}\nfunction updateRunButton() {\n  runner.innerHTML = gState.running ? RunButtonContents.RUNNING : RunButtonContents.PAUSED;\n}\nfunction toggleRunButton() {\n  gState.running = !gState.running;\n  updateRunButton();\n}\n\nvar runButton = document.getElementById(\"run\");\nrunButton.addEventListener('click', toggleRunButton);\nupdateRunButton();\n\n\n\n//---- Initialization --------------------------------------------------------------------------------------------------------- \ninit_Params_Measures(gState);\n\n\n//---- Map Rendering ----------------------------------------------------------------------------------------------------------\ninitLegend();\n\n//---- Load & Preprocess Data -------------------------------------------------------------------------------------------------\n\nd3.queue()\n  .defer(d3.json, \"data/landkreise_simplify200.geojson\")\n  .defer(d3.csv, \"data/7T_Inzidenz_LK_22_1.csv\", function (d) {\n    gState.incidence.push({ name: d.Landkreis, tag: d.LKNR, active: d.Anzahl, inc: d.Inzidenz })\n  })\n  .await((e,t) => start_sim(e,t,gState));\n","import \"./sass/default.scss\";\n\nimport {\n    avg7_incidence,\n  } from './game-engine';\n\n\nfunction createElementFromHTML(html) {\n    let div = document.createElement('div');\n    div.innerHTML = html.trim();\n    return div;\n  }\n\n\n//---- Map Rendering ----------------------------------------------------------------------------------------------------------\nvar svg = d3.select(\"svg\");\nvar svg_width = 300;\nvar svg_height = 400;\n\n// Map and projection\nvar path = d3.geoPath();\nvar projection = d3.geoMercator()\n  .scale(2200)\n  .center([12, 52])\n  .translate([svg_width / 2, svg_height / 2]);\n\n// Data and color scale\n// var data = d3.map();\nvar legendValues = [5, 25, 50, 100, 150, 200, 300, 400];\nvar colorScale = d3.scaleThreshold()\n  .domain(legendValues)\n  .range(d3.schemeOrRd[legendValues.length + 1]);\n\nexport function initLegend() {\n  let cm = document.getElementById('legend');\n  var firstLegendString = '< '.concat(legendValues[0].toString());\n  cm.appendChild(createElementFromHTML(\n    `<span class=\"legendspan\" style=\"background-color:${colorScale(legendValues[0] - 1)};\"></span> <label >${firstLegendString}</label><br>`\n  ));\n  for (var i = 1; i < legendValues.length; i++) {\n    var legendString = ''.concat(legendValues[i - 1].toString(), ' - ', legendValues[i].toString());\n    cm.appendChild(createElementFromHTML(\n      `<span class=\"legendspan\" style=\"background-color:${colorScale(legendValues[i] - 1)};\"></span> <label >${legendString}</label><br>`\n    ))\n  }\n  var lastLegendString = '> '.concat(legendValues[legendValues.length - 1].toString());\n  cm.appendChild(createElementFromHTML(\n    `<span class=\"legendspan\" style=\"background-color:${colorScale(legendValues[legendValues.length - 1])};\"></span> <label >${lastLegendString}</label><br>`\n  ));\n}\n\nfunction draw_map_d3(topo, fill_fn) {\n  // TODO: This recreates all geometry, we should only update the final fill state.\n  svg.selectAll(\"g\").remove();\n  svg.append(\"g\")\n    .selectAll(\"path\")\n    .data(topo.features)\n    .enter()\n    .append(\"path\")\n    .attr(\"d\", d3.geoPath().projection(projection))     // draw each country\n    .attr(\"fill\", fill_fn);                             // set the color of each country\n}\n\n\nexport function draw_map(topo, state) {\n    draw_map_d3(topo, function (f) {\n      let ctag = f.properties.AGS;\n      let cr = state.regions.find(e => e.tag == ctag);\n      return colorScale(avg7_incidence(cr));\n    });\n  }","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module\n__webpack_require__(\"./src/main.js\");\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}