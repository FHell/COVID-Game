<!DOCTYPE html>
<meta charset="utf-8">

<head>
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src='https://unpkg.com/@turf/turf/turf.min.js'></script>

<style>
html, body              { } 
.grid-container         { display: grid; grid-template-columns: 0.5fr 1fr; grid-template-rows: min-content 1fr; gap: 0px 0px;
                         grid-template-areas:
                            "ctrl time"
                            "ctrl map";
                        }
.map                    { grid-area: map; width:600px; height: 800px; }
.time                   { grid-area: time; font-size: small;}
.ctrl                   { grid-area: ctrl; }
</style>
</head>

<body>
<h2>PROTOTYPE - NOT A REALISTIC OR EVEN PLAUSIBEL MODEL (YET)</h2>

Development at <a href="https://github.com/FHell/COVID-Game/">https://github.com/FHell/COVID-Game/</a>.

<div class="grid-container">
<svg class="map" id="germany"></svg>
<div class="ctrl">
    <h6>Counter Measures</h6> 

    <div id="cm"></div>
    <div id="param"></div>
</div>
<div class="time">
    <label for="cd">Time (<span id="cdo"></span> days):</label></p>
    <input id="cd" type="range" min="1" max="200" value="0">
    <button id="run" onclick="toggleRunning()">Run!</button>
</div>
</div>
</body>

<script src="covid-game-V2.js"></script>

<script>
//---- Controls ---------------------------------------------------------------------------------------------------------------
var slider = document.getElementById("cd");
var output = document.getElementById("cdo");
    output.innerHTML = slider.value; 
    slider.disable;

var running = false;  // TODO: this should be in State
var runner = document.getElementById("run");
function toggleRunning() {
    running = !running;
    runner.innerHTML = running ? "Pause" : "Run";
}

function slider_set_value(value) {
    output.innerHTML = value;
    slider.value = value;
}

var gState = null;

function createElementFromHTML(html) {
    console.log(html);
    var div = document.createElement('div');
    div.innerHTML = html.trim();

    return div;
}

function initMeasures() {
    let cm = document.getElementById("cm");
    Object.entries(possible_measures).forEach((e, i) => cm.appendChild(createElementFromHTML(
        `<input type="checkbox" id="m${i}" name="measure${i}" onchange="toggleMeasure(this);" value="${e[0]}"> <label for="m${i}">${e[1].desc}</label><br>`
    )));
}
initMeasures();

function toggleMeasure(cb) {
    if (gState == null) { return; }
    gState.measures.toggle(cb.value);
}

//---- Map Rendering ----------------------------------------------------------------------------------------------------------
var svg = d3.select("svg");
    var svg_width = +svg.property("clientWidth");
    var svg_height = +svg.property("clientHeight");

// Map and projection
var path = d3.geoPath();
var projection = d3.geoMercator()
    .scale(2200)
    .center([12,52])
    .translate([svg_width / 2, svg_height / 2]);

// Data and color scale
var data = d3.map();
var colorScale = d3.scaleThreshold()
    .domain([5, 25, 50, 100, 150, 200, 300, 400])
    .range(d3.schemeOrRd[9]);

function draw_map_d3(topo, fill_fn) {
    // TODO: This recreates all geometry, we should only update the final fill state.
    svg.selectAll("g").remove();
    svg.append("g")
        .selectAll("path")
        .data(topo.features)
        .enter()
        .append("path")
            .attr("d", d3.geoPath().projection(projection))     // draw each country
            .attr("fill", fill_fn);                             // set the color of each country
}

//---- Handle Simulation State ------------------------------------------------------------------------------------------------

class State {
    constructor(regions, measures = new Measure_State()) {
        this.regions = regions;
        this.measures = measures;
        this.step_no = 0;
    }
}

function draw_map(topo, state) {
    draw_map_d3(topo, function (f) {
        let ctag = f.properties.AGS;
        let cr = state.regions.find(e => e.tag == ctag);
        return colorScale(infected(cr));
    });
}

function simulate_step(state) {
    state.step_no++;
    step_epidemic(state.regions, state.measures, 0.01);
}

function draw_step(topo, state) {
    if (state.step_no >= slider.max) { running = false; }
    if (!running) { return; }

    simulate_step(state);
    draw_map(topo, state);

    slider_set_value(state.step_no)
    console.log("Rendered state", state);
}


//---- Load & Preprocess Data -------------------------------------------------------------------------------------------------

var incidence = [];
function findIncidence(ctag, def) {
    let incr = incidence.find(e => e.tag == ctag);
    if (incr == null)  {
        console.log("No match for tag ", ctag, " => set to default ", def);
        return def;
    } else {
        return incr.inc;
    }
}

d3.queue()
    .defer(d3.json, "landkreise_simplify200.geojson")
    .defer(d3.csv, "7T_Inzidenz_LK_22_1.csv", function(d) {  
        incidence.push({ name: d.Landkreis, tag: d.LKNR, active: d.Anzahl, inc: d.Inzidenz })
    })
    .await(start_sim);

function start_sim(error, topo) {
    var regions = []
    topo.features.forEach(e => { 
        let inc = findIncidence(e.properties.AGS, 115); // TODO: default incidence hardcoded to 115, should be average from CSV dataset
        let r = region_with_incidence(e.properties.destatis.population, inc, e.properties.AGS, e.properties.GEN)
            // for distance between regions 
            // two passes to prevent expensive recalculation
            r.centerOfMass = turf.centerOfMass(e.geometry).geometry.coordinates;
        regions.push(r);
    });

    // second pass ... finish up distance calculations
    regions.forEach((src_r) => {
        regions.forEach((dst_r, i) => {
            src_r.neighbours.push({index: i, dist: turf.distance(src_r.centerOfMass, dst_r.centerOfMass)});
        });
    });


    gState = new State(regions);
    console.log("Initial State = ", gState);

    draw_map(topo, gState);

    console.log("done");

    // TODO: find out how to trigger and stop this timer on demand, right now we just 
    //       keep up "the beat" and decide to do breaks if needed. 
    setInterval(draw_step, 1000, topo, gState);
}

//-----------------------------------------------------------------------------------------------------------------------------
</script>
