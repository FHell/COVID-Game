<!DOCTYPE html>
<meta charset="utf-8">

<head>
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src='https://unpkg.com/@turf/turf/turf.min.js'></script>

<style>
    @supports(-webkit-appearance: none) or (-moz-appearance: none) {
  input[type='checkbox'],
  input[type='radio'] {
    --active: #1777af;
    --active-inner: #fff;
    --focus: 2px rgba(39, 94, 254, .3);
    --border: #BBC1E1;
    --border-hover: #275EFE;
    --background: #fff;
    --disabled: #F6F8FF;
    --disabled-inner: #E1E6F9;
    -webkit-appearance: none;
    -moz-appearance: none;
    height: 21px;
    outline: none;
    display: inline-block;
    vertical-align: top;
    position: relative;
    margin: 2px;
    cursor: pointer;
    border: 1px solid var(--bc, var(--border));
    background: var(--b, var(--background));
    transition: background .3s, border-color .3s, box-shadow .2s;
  }
  input:after {
      content: '';
      display: block;
      left: 0;
      top: 0;
      position: absolute;
      transition: transform var(--d-t, .3s) var(--d-t-e, ease), opacity var(--d-o, .2s);
    }
input:checked {
      --b: var(--active);
      --bc: var(--active);
      --d-o: .3s;
      --d-t: .6s;
      --d-t-e: cubic-bezier(.2, .85, .32, 1.2);
    }

    
html, body              { } 
.grid-container         { display: grid; grid-template-columns: 0.5fr 1fr; grid-template-rows: min-content 1fr; gap: 0px 0px;
                         grid-template-areas:
                            "ctrl time"
                            "ctrl map";
                        }
.map                    { grid-area: map; width:600px; height: 800px; }
.time                   { grid-area: time; font-size: small;}
.ctrl                   { grid-area: ctrl; }
.switch {
      width: 38px;
      border-radius: 11px; }
.switch:after {
        left: 2px;
        top: 2px;
        border-radius: 50%;
        width: 15px;
        height: 15px;
        background: var(--ab, var(--border));
        transform: translateX(var(--x, 0));
      }
.switch:checked {
        --ab: var(--active-inner);
        --x: 17px;
      }
.legendspan { border: 1px solid #ccc; float: left; width: 16px; height: 16px; margin-left: 2px; margin-right: 2px; border-radius: 4px;}
.textfield{border: 1px solid #ccc; height: 21px; border-radius: 4px; margin: 2px; padding: 4px;}
button{border: 0px; border-radius: 4px; background-color:#1777af; color:#FFFFFF; height:32px; min-width: 64px;}
button:hover{background-color:#14608b;} 
label{margin-left: 4px;}
</style>
</head>

<body>
<h2>PROTOTYPE</h2>

The underlying model is not tuned to real parameters yet, so effectiveness of measures, spreading to neighbouring counties, and time scales are off.
It does include the following aspects of COVID-19:
<ul>
<li>Overdispersion and superspreader events.</li>
<li>Travel between regions</li>
<li>More virulent mutation</li>
<li>Vaccinations</li>
<li>Limits on the effectiveness of test and trace at high incidence</li>
<li>Infections coming from outside Germany</li>
</ul>

It is based on a stochastic SEIR with a negative binomial for the infection step.

The color scale on the map shows the average of the last 7 days.

Thus Players can try out themself how to sequence different level of measures to avoid the thrid lockdown, and the various trade-offs involved.

Development at <a href="https://github.com/FHell/COVID-Game/">https://github.com/FHell/COVID-Game/</a>.

<div class="grid-container">
<svg class="map" id="germany"></svg>
<div class="ctrl">
    <h6>Counter Measures</h6> 

    <div id="cm"></div>
    <div id="param"></div>
    <br>
    <h6>Legend</h6>
    <div id="legend"></div>
</div>
<div class="time">
    <label for="cd">Time (<span id="cdo"></span> days):</label></p>
    <input id="cd" type="range" min="1" max="200" value="0">
    <button id="run" onclick="toggleRunning()">Run!</button>
</div>
</div>
</body>

<script src="covid-game-V2.js"></script>

<script>
//---- Controls ---------------------------------------------------------------------------------------------------------------
var slider = document.getElementById("cd");
var output = document.getElementById("cdo");
    output.innerHTML = slider.value; 
    slider.disable;

var running = false;  // TODO: this should be in State
var runner = document.getElementById("run");
function toggleRunning() {
    running = !running;
    runner.innerHTML = running ? "Pause" : "Run";
}

function slider_set_value(value) {
    output.innerHTML = value;
    slider.value = value;
}

var gState = null;

function createElementFromHTML(html) {
    let div = document.createElement('div');
    div.innerHTML = html.trim();
    return div;
}

function initMeasures() {
    let cm = document.getElementById("cm");
    Object.entries(possible_measures).forEach((e, i) => cm.appendChild(createElementFromHTML(
        `<input type="checkbox" id="m${i}" name="measure${i}" class="switch" onchange="toggleMeasure(this);" value="${e[0]}"> <label for="m${i}">${e[1].desc}</label><br>`
    )));
}
initMeasures();

function toggleMeasure(cb) {
    if (gState == null) { return; }
    gState.measures.toggle(cb.value);
}

function initParams() {
    let cm = document.getElementById("param");
    Object.entries(cov_pars).forEach((e, i) => cm.appendChild(createElementFromHTML(
        `<input class="textfield" type="number" id="p${i}" step="0.1" min="0" max="1.0" onchange="changeParams(this);" value="${e[1].value}" cp_id="${e[0]}"><label for="p${i}">${e[1].desc}</label><br>`
    )));
}
initParams();

function changeParams(tf) {
    if (gState == null) { return; }
    cov_pars[tf.getAttribute("cp_id")].value = parseFloat(tf.value) || cov_pars[tf.getAttribute("cp_id")].def;
    console.log(cov_pars);
}

//---- Map Rendering ----------------------------------------------------------------------------------------------------------
var svg = d3.select("svg");
    var svg_width = +svg.property("clientWidth");
    var svg_height = +svg.property("clientHeight");

// Map and projection
var path = d3.geoPath();
var projection = d3.geoMercator()
    .scale(2200)
    .center([12,52])
    .translate([svg_width / 2, svg_height / 2]);

// Data and color scale
var data = d3.map();
var legendValues = [5, 25, 50, 100, 150, 200, 300, 400];
var colorScale = d3.scaleThreshold()
    .domain(legendValues)
    .range(d3.schemeOrRd[legendValues.length + 1]);

    function initLegend() {
        let cm = document.getElementById('legend');
        var firstLegendString = '< '.concat(legendValues[0].toString());
        cm.appendChild(createElementFromHTML(
            `<span class="legendspan" style="background-color:${colorScale(legendValues[0] - 1)};"></span> <label >${firstLegendString}</label><br>`
        ));
        for (var i = 1; i < legendValues.length; i++) {
            var legendString = ''.concat(legendValues[i - 1].toString(), ' - ', legendValues[i].toString());
            cm.appendChild(createElementFromHTML(
                `<span class="legendspan" style="background-color:${colorScale(legendValues[i] - 1)};"></span> <label >${legendString}</label><br>`
            ))
        }
        var lastLegendString = '> '.concat(legendValues[legendValues.length - 1].toString());
        cm.appendChild(createElementFromHTML(
            `<span class="legendspan" style="background-color:${colorScale(legendValues[legendValues.length - 1])};"></span> <label >${lastLegendString}</label><br>`
        ));
    }
    initLegend();

function draw_map_d3(topo, fill_fn) {
    // TODO: This recreates all geometry, we should only update the final fill state.
    svg.selectAll("g").remove();
    svg.append("g")
        .selectAll("path")
        .data(topo.features)
        .enter()
        .append("path")
            .attr("d", d3.geoPath().projection(projection))     // draw each country
            .attr("fill", fill_fn);                             // set the color of each country
}

//---- Handle Simulation State ------------------------------------------------------------------------------------------------

class State {
    constructor(regions, measures = new Measure_State()) {
        this.regions = regions;
        this.measures = measures;
        this.step_no = 0;
    }
}

function draw_map(topo, state) {
    draw_map_d3(topo, function (f) {
        let ctag = f.properties.AGS;
        let cr = state.regions.find(e => e.tag == ctag);
        return colorScale(avg7_incidence(cr)); 
    });
}

function simulate_step(state) {
    state.step_no++;
    step_epidemic(state.regions, state.measures, 0.01);
}

function draw_step(topo, state) {
    if (state.step_no >= slider.max) { running = false; }
    if (!running) { return; }

    simulate_step(state);
    draw_map(topo, state);

    slider_set_value(state.step_no)
    console.log("Rendered state", state);
}


//---- Load & Preprocess Data -------------------------------------------------------------------------------------------------

var incidence = [];
function findIncidence(ctag, def) {
    let incr = incidence.find(e => e.tag == ctag);
    if (incr == null)  {
        console.log("No match for tag ", ctag, " => set to default ", def);
        return def;
    } else {
        return incr.inc;
    }
}

d3.queue()
    .defer(d3.json, "landkreise_simplify200.geojson")
    .defer(d3.csv, "7T_Inzidenz_LK_22_1.csv", function(d) {  
        incidence.push({ name: d.Landkreis, tag: d.LKNR, active: d.Anzahl, inc: d.Inzidenz })
    })
    .await(start_sim);

function start_sim(error, topo) {
    var regions = []
    topo.features.forEach(e => { 
        let inc = findIncidence(e.properties.AGS, 115); // TODO: default incidence hardcoded to 115, should be average from CSV dataset
        let r = region_with_incidence(e.properties.destatis.population, inc, e.properties.AGS, e.properties.GEN)
            // for distance between regions 
            // two passes to prevent expensive recalculation
            r.centerOfMass = turf.centerOfMass(e.geometry).geometry.coordinates;
        regions.push(r);
    });

    // second pass ... finish up distance calculations
    regions.forEach((src_r) => {
        regions.forEach((dst_r, i) => {
            src_r.neighbours.push({index: i, dist: turf.distance(src_r.centerOfMass, dst_r.centerOfMass)});
        });
    });


    gState = new State(regions);
    console.log("Initial State = ", gState);

    draw_map(topo, gState);

    console.log("done");

    // TODO: find out how to trigger and stop this timer on demand, right now we just 
    //       keep up "the beat" and decide to do breaks if needed. 
    setInterval(draw_step, 1000, topo, gState);
}

//-----------------------------------------------------------------------------------------------------------------------------
</script>
